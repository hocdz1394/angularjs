"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var chart_js_1 = require("chart.js");
var colors_1 = require("./colors");
var ChartsDirective = (function () {
    function ChartsDirective(el) {
        this.el = el;
        this.options = {};
        this.chartClick = new core_1.EventEmitter();
        this.chartHover = new core_1.EventEmitter();
        this.initFlag = false;
    }
    ChartsDirective.prototype.ngOnInit = function () {
        this.ctx = this.el.nativeElement.getContext('2d');
        this.cvs = this.el.nativeElement;
        this.initFlag = true;
        if (this.data || this.datasets) {
            this.refresh();
        }
    };
    ChartsDirective.prototype.ngOnChanges = function (changes) {
        if (this.initFlag) {
            if (changes.hasOwnProperty('data') ||
                changes.hasOwnProperty('datasets')) {
                var currentValue = changes['datasets'].currentValue || changes['data'].currentValue;
                this.updateChartData(currentValue);
                this.chart.update();
            }
            else {
                this.refresh();
            }
        }
    };
    ChartsDirective.prototype.ngOnDestroy = function () {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
    };
    ChartsDirective.prototype.getChartBuilder = function (ctx) {
        var _this = this;
        var datasets = this.getDatasets();
        var options = Object.assign({}, this.options);
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = function (active) {
                if (active && !active.length) {
                    return;
                }
                _this.chartHover.emit({ active: active });
            };
        }
        if (!options.onClick) {
            options.onClick = function (event, active) {
                _this.chartClick.emit({ event: event, active: active });
            };
        }
        var opts = {
            type: this.chartType,
            data: {
                labels: this.chartLabels,
                datasets: datasets
            },
            options: options
        };
        return new chart_js_1.Chart(ctx, opts);
    };
    ChartsDirective.prototype.refresh = function () {
        this.chart = this.getChartBuilder(this.ctx);
    };
    ChartsDirective.prototype.getDatasets = function () {
        var _this = this;
        var datasets = void 0;
        if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
            if (Array.isArray(this.data[0])) {
                datasets = this.data.map(function (data, index) {
                    return { data: data, label: _this.chartLabels[index] || "Label " + index };
                });
            }
            else {
                datasets = [{ data: this.data, label: "Label 0" }];
            }
        }
        console.log(datasets);
        if (this.datasets && this.datasets.length ||
            (datasets && datasets.length)) {
            datasets = (this.datasets || datasets).map(function (elm, index) {
                var newElm = Object.assign({}, elm);
                if (_this.colors && _this.colors.length) {
                    Object.assign(newElm, _this.colors[index]);
                }
                else {
                    Object.assign(newElm, colors_1.getColors(_this.chartType, index, newElm.data.length));
                }
                return newElm;
            });
        }
        if (!datasets) {
            throw new Error("ng-charts configuration error,\n      data or datasets field are required to render char " + this.chartType);
        }
        return datasets;
    };
    ChartsDirective.prototype.updateChartData = function (newDataValues) {
        if (Array.isArray(newDataValues[0].data)) {
            this.chart.data.datasets.forEach(function (dataset, i) {
                dataset.data = newDataValues[i].data;
                if (newDataValues[i].label) {
                    dataset.label = newDataValues[i].label;
                }
            });
        }
        else {
            this.chart.data.datasets[0].data = newDataValues;
        }
    };
    return ChartsDirective;
}());
ChartsDirective.decorators = [
    { type: core_1.Directive, args: [{
                selector: 'canvas[ykChart]',
                exportAs: 'yk-chart'
            },] },
];
ChartsDirective.ctorParameters = function () { return [
    { type: core_1.ElementRef, },
]; };
ChartsDirective.propDecorators = {
    'chartType': [{ type: core_1.Input },],
    'chartLabels': [{ type: core_1.Input },],
    'colors': [{ type: core_1.Input },],
    'data': [{ type: core_1.Input },],
    'datasets': [{ type: core_1.Input },],
    'options': [{ type: core_1.Input },],
    'chartClick': [{ type: core_1.Output },],
    'chartHover': [{ type: core_1.Output },],
};
exports.ChartsDirective = ChartsDirective;
//# sourceMappingURL=charts.directive.js.map